5722018474	I'm just starting to learn Python. This looks like a useful feature, does anyone know if there's an easy way to do this in The Py? I've had a poke around i the documentation, but can't find anything yet.It actually is pretty easy in PHP... this is exactly what the ruby's Enumerable#sort() method does. Except ruby has blocks, so you don't have to define a function, you just inline the code, and it works for every data structure that defines each be it an array or tree or hash or whatever.Is there anything like this in Python? n ot really, as in the php case in the former comment, this is not what sort_by() does in ruby. You can see there are two arguments in this python version, and just one in the ruby one. This basically mean that for each iteration you build two new objects, and this is quite a bit slower.Ruby Blocks and Iterators you find this sort of thing happens in every single data type.  There is little need for the FOR loop in Ruby (it's there if you really need it) but blocks are so much cleaner and readable.But I would suggest that comprehensive unit tests are a better way of expecting change, even the change of being able to add extra encapsulation that you didn't (and often couldn't) forsee without breaking everything and causing regressions.You definitely want to use shipping tables that are decoupled from the order.  It's best I've found to work at the line item level.  You know that peopel will want to ship different items from the same order to different locations.  You also need to consider different paymnt options per line item.  In a B2B scenario you often have ordre with multiple line items and each line item is paid via   a different PO.Is also nice to have a generic attribute module that you can use to apply attributes to any object in your system.  Attributes can be created for products, orders, shipments, payments, etc.  You can then have one interface for maintaining these attributes, they do not have to be added separately in each module.The idea of writing code for all of the possible shipping variations is daunting, to say the least. You might want to consider using a rule-based system instead, where you just maintain a table of rules, and write one chunk of code that figures out which rules to apply to a specific shipment.In our case, we moved shipment info to another table to allow shoppers to ship goods to multiple addresses. For instance, they may buy an item for themselves and a gift for someone else (all on the same order). We also found that it allowed the system to charge customers only as their products were shipped.I felt views would be too "expensive" since sometimes the queries it takes to create these subset-stores will be complex.   Though I gave the example of "a jazz store", above, some will be as complex as "Midwest Bluegrass" which will have to only include products from one of 5 states in the USA with their musical style set to one of two styles.You've got some binding between the default values and the function.  It'd be better to just have an "on create" trigger for your table, where if you provide NULL values, you stuff it with the next entries.  That'd make more sense to me.Columns like first_name, last_name seem like a better way to go plus when someone has a first name like 'mary ann' or 'anna maria' or maybe 'sir raleigh' they don't get bogus greetings like "welcome back sir.  Or am a I missing something?Developer Testing Forum interesting. (the talk by Sriram Sankar about developer testing at Google is also well worth it). If you prefer audio-only Kent's talk is also on ITConversations in other formats.What is the exact problem here? If the problem is that drawing the UI takes too much effort (and it sounds like it is) then the solution, as you seem to have explored, is something in the line of a template engine, rather than a framework.Also a template engine itself may not make your life easier (and many will make it harder) unless it provides some mechanism for you to build re-usable user interface components (e.g. a reusable result set pager).The alternative view is some form of declarative markup. The leaders of the field here are Microsoft with ASP.NET but there's also Java's Taglibs and more recently Java Server Faces. The easiest way to think about declarative template markup is simply as an extension to HTML's own tag set to include addition tags with names like "calendar" and "dataset". The "extended tags" only exist on the server side (within the template), the end result being normal HTML delivered to the client. In some ways this approach is the best suited to building reusable UI components. The downside of this approach is it adds alot of complexity (plus wierd employment of Javascript in the case of ASP.NET and JSF).In general, highly recommend reading this study of template engines http://wact.sourceforge.net/index.php/TemplateView. It doesn't advocate a particular approach but helps alot in understanding the general problem, which can help alot in narrowing requirements. The bottom line, IMO, is no one has got the perfect solution for everyone (no matter what they tell you).There's also an MVC implementation in there so you have the option of using WACT as a framework as well. The more of WACTs components you use, the more benefits you gain (e.g. template engine + MVC controllers makes for very powerful form handling) but the more of your existing code you're likely to need to re-write.I've been reading up on Cocoon and it looks like a very promising application framework to me. It is completely based on XML, so I'm not sure if it applies to you. There is also a group of people who are porting Cocoon to PHP. They called it Popoon.. just google bitflux and/or popoon and you'll find the page.Is there anything like that for PHP/Java? Wouldn't such a solution be a big push for fast development  of PHP/Java based large scale applications? From what I understand of w.g. horde, they're only dealing with the plain basics, but this would go much further into direction of a *full* framework.Perhaps you should look into zoopframework for php. It supports smarty for templates, but also supports you not using smarty. It is quite stable and mature, being used in production for the last 5 years. It has a few features unique to it, one being guiControls and another being forms. Other than that it also has all that you would expect a mature framework to have including MVC and AJAX support.One habit I got in recently is to spend more time looking at (and thinking through) the details of my user interface before coding. Until recently, I had always accomplished this by throwing a mockup together in Photoshop, or using a crappy WYSIWYG HTML editor to do a slap dash mock up.  Perhaps you already have a method you use for this - your sites are always really usable, so I imagine you must put a lot of thought into it.Anyway, I recently discovered a great tool for this purpose - called Axure. It's a prototyping tool - you use a WYSIWYG editor to create your web interface, annotate it with little notes about how different elements behave, and then click a button and it spits out a "click through" prototype web site. It's a very quick affair, but can really help you think through interface issues you wouldn't have thought of otherwise.On an application I worked on a few years back, written in ASP, we started with that idea (thinking of the action pages as "router" pages). Our big breakthrough came in shifting our thinking about it a little bit, and seeing those pages as "Event" pages. I.e. the function that gets called by the switch statement is something like "SaveButton_OnClick". That way it's very obvious from the coding point of view what action you're writing code to. We went one step further and actually had the name of the button automatically determine which function gets called (by attempting to evaluate an expression using the name of the button plus "_OnClick"). That eliminated the nasty switch statements, and gives you the opportunity to do something sensible if they click a button that has no handler.Finally, we also ended up breaking the pages up into discrete "Event" pages for each system page ... so you'd have a "ItemDisplay_Event" page, a "Preference_Event" page, etc. That's helpful if your one action page gets too big.I have an "Active" folder which only allows whitelisted people.  Then I have my general inbox for catching things that aren't whitelisted.  Then I have my normal spam box.  I haven't had a misclassified legitimate message in months.With just a little tweaking, you could make this an actual Makefile. You'd just say make foo.ogg assuming there's a foo.mp3 and you wouldn't have to remember anything. And assuming the Makefile's in the directory or you've put a #!/usr/bin/make -f at the top of the Makefile, made it executable, and put it in your bin directory with a sensible name.Go for it!  I'm going to be turning them into some PHP classes to interface with some other stuff I'm doing, but please feel free to take this stuff (that's why I posted it!) and use it for whatever you'd like.I need to convert WAV to MP3. I want to do it on a server that I don't have administrative access to. I assume the server has any normal Unix libraries, but I don't know about special (e.g. audio format plugins) libraries or plug-ins. I am using PHP as my main script language and I want to make the final mp3 file available for download. Can you help me?There's no reason at all why you need to inconvenience your users while you move to a sane system of one user, one password.  Check the new and old data during the login process untill you get a match -- treat the old data as user aliases.The system knows which user has access to which domains â€” why'd they have to provide credentials for each? It makes no sense. A single username and one password should grant access to all domains registered to that user.Sorry if I wasn't clear about this : the 